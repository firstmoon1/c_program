

#include <stdlib.h>
#include <string.h>
typedef struct exp{
    int age;
    int weight;
}man;
int main(){
    int size,i;
    scanf("%d",&size);
    man *n1;
    n1=(man*)malloc(sizeof(man)*size);
    for(i=0;i<size;i++){
        scanf("%d%d",&n1[i].age,&(*(n1+i)).weight);
    }
    for(i=0;i<size;i++){
        printf("%d %d\n",n1[i].age,(*(n1+i)).weight);
    }

    //scanf("%d%d",&n1[i].age,&(n1+i)->weight);
    //printf("%d %d\n",n1[i].age,(n1+i)->weight);
    
    //scanf  &(*(n1+i)).weight
    //printf  (*(n1+i)).weight
    
    //scanf("%d%d",&(p+i)->age,&(p+i)->weight);
    //printf("%d %d\n",(p+i)->age,(p+i)->weight);
    
    
    
    
   /* int *p,i,size,k;
    scanf("%d",&size);
    p=(int*)malloc(size*sizeof(int*));
    for(i=0;i<size;i++){
        for(k=0;k<2;k++){
        scanf("%d",&p[k]);
        printf("%d ",p[k]);
        }
        printf("\n");
    }
  */
    return 0;
}













#include <stdio.h>
#include <string.h>

typedef struct man{
    char book[20];
    char book1[20];
}marry;

marry *fuc(marry *st3){
    strcpy((*st3).book,"C Programming");
    strcpy((*st3).book1,"C++ Programming");
    return st3;
}

int main(){
    marry *a3,bok;
    a3=&bok;
    a3=fuc(a3);
     printf("%s\n%s",(*a3).book,a3->book1);
    
    return 0;
}






#include <stdio.h>
#include <string.h>
typedef struct man{
    int book[2];
}marry;
void fuc(marry st1,marry st2,marry *st3){
    st3->book[0]=st1.book[0];
    (*st3).book[1]=st2.book[0];
   
}
int main(){
    marry kayip_vaka1,kayip_vaka2,kayip_vaka3;
    kayip_vaka1.book[0]=1213;
    kayip_vaka2.book[0]=1214;
    fuc(kayip_vaka1,kayip_vaka2,&kayip_vaka3);
     printf("%d\n%d",kayip_vaka3.book[0],kayip_vaka3.book[1]);
    
    return 0;
}








pointer ile ilgili bir yaptıgım kendim
#include <stdio.h>
#include <string.h>
char *func(char *m[],int size,int num){
    if(num>=0 && num<=7){
        return m[num-1];
    }else{
        return NULL;
    }
}
int main(){
    char *arr[]={"monday","tuesday","wednesday","thursday","friday","saturday","sunday"};
    char *p;
    p=func(arr,7,1);
    if(p==NULL){
        printf(".NULL.");
    }else{
        printf("%s",p);
    }
	return 0;
	}	









/*
#include <stdio.h>
char *fuck(char *m[],int size){
int a=strlen(m);
if(a<size){
    return 0;
}else{
return m+size;
}
}
int main(){

char arr[]="ebru 11 kez bosaldi";
char *p=fuck(arr,0);
if(p==0){
    printf("%s",p);
}else{
printf("%s",p);
}
return 0;
}
*/







/*
#include <stdio.h>
char *p;
int fuck(char *b){
int size=0,i=0;
for(;b[i]!='\0';i++){
        size++;
}
return size;
}
int main(){
    char arr[]="ilkay";
    //char
    p=arr;
    //printf("%s",&arr[0]/*p veya arr veya p+1 =lkay yazdırır felan*///);
   /* printf("str %d\n",strlen(arr));
    printf("fuck %d\n",fuck(arr));*/
return 0;
}







#include <stdio.h>
/*int fuc(int *a,int size){
int max=a[0],i;
for(i=0;i<size;i++){
    if(max<a[i]){
        max=a[i];
    }
}
return max;
}
int main(){
    int arr[5]={1,2,3,4,5},max;
   max=fuc(arr,5);
   printf("%d",max);
   return 0;
}
*/






/*
#include <stdio.h>
int main(){
int arr[]={1,2,3,4,5};
int *p=arr;
int i;
printf("%u\n",p+1);
printf("%u\n",p+2);
printf("%u\n",p+3);
printf("%u\n\n",p+4);

printf("%d ",*p);
printf("%d ",*(p+1));
printf("%d ",*(p+2));
printf("%d ",*(p+3));
printf("%d \n\n",*(p+4));

printf("%d ",p[0]);
printf("%d ",p[1]);
printf("%d ",p[2]);
printf("%d ",p[3]);
printf("%d \n",p[4]);
for(i=0;i<5;i++)
    printf("  %d",p[i]);

return 0;
}
*/






/*  #include <stdio.h>
    void fuc(int *n1,int *n2){
    int temporary=*n2;
    *n2=*n1;
    *n1=temporary;
}
int main(){
  int a=10,b=20;
  fuc(&a,&b);
  printf("a=%d, b=%d",a,b);
return 0;
}
*/





   /*
    #include <stdio.h>
     int main(){
    int num1,num2=5,*n1p,*n2p;
    n2p=&num2;
    //n2p=num2 adres olarak
    //n1p=n2p;
    //n1p=num2 adres olarak
    num1=++(*n2p)+1;
    //num1=7
    n1p=&num1;
    // num1 =7  n2p =6 num2 =6 n1p=7
    printf("num1=%d, num2=%d, *n1p=%d,*n2p=%d",num1,num2,*n1p,*n2p);
    // num1=7,num2=6,n1p=7,n2p=6
    return 0;
    }
   */





  /*
  #include <stdio.h>
  int main(){
  int a=7,*ap;
  float f=6.2,*fp;
  double d=8.02,*dp;
  char c='k',*cp;
  int arr[]={1,2,3,4,5},*arrp;
  ap=&a;
  fp=&f;
  dp=&d;
  cp=&c;
  arrp=&arr[1];
  printf("ap=%u adresindeki num a = %d\n",ap,*ap);
   printf("fp=%u adresindeki num f = %0.2f\n",fp,*fp);
    printf("dp=%u adresindeki num d = %0.2lf\n",dp,*dp);
     printf("cp=%u adresindeki num c = %c\n",cp,*cp);
      printf("arrp=%u adresindeki num arr = %d\n",arrp,*arrp);
    */
  /* int i=7;
   int *po =&i;
   printf("%p  & %u\n",po,po);
   printf("%d",*po);
  */
    return 0;
}





/*
#include <stdio.h>
int *fuc(int *p,int wanted){

    printf("addres of p yani arr=%d ve content=%d\n",&p[wanted-1],p[wanted-1]);

    return p[wanted-1]; //  &p[wanted-1] adres gönderiyor ,   p[wanted-1]   content gönderiyor
    /* arraylarde biz  & koymayız bu durumda return deki gibi, yazılım biliminde anlattıgı gibi, bu şekilde
    zaten içerik veriyor,aynen içerik p[1] veya p[2]  bunlar içerik bro, normalde pointerleri ögrenemden önce
    arraylari printf lerken de  bu & uncertainty i koymuyorduk.bunda da koymuyoruz,kısaca returnde gönderdigimiz şey 
    content dir (içerik).
*/
/*
}
int main(){
int arr[]={1,2,3,4,5};
int *p1;
p1=fuc(arr,1);
//printf("address of arr=%d  content of arr=%d  address of p1=%d\n",p1,*p1,&p1);
printf("%d\n",p1);
printf("address of arr=%d\n",&arr[0]);
return 0;
}
*/








#include <stdio.h>
#include <math.h>
int main(){
float x=-2.1,i;
int k,z;
i=fabs(x);// absolute degerini alıyor mutlak deger işlemi yapıyor,output=2.1
k=floor(x);//sayıyı yuvarlıyor kücügüne,input= -2.1 ,output=-3 ,   intput=2.1 output=2
z=floor(i);
printf("fabs=%.1f\nfloor(-2.1)=%d\nfloor(2.1)=%d",i,k,z);
return 0;
}


pointer denemesi
#include <stdio.h>
char *fuc(char *p1[],int size){
    return p1[size-1];
}
int main(){
    int size=1;
   char *p[7]={"monday","tuesday","wednesday","thursday","friday","saturday","sunday"};
   char *m=fuc(p,size);
   printf("%s",m);
   /*char **n=&m;
   printf("%s",*n);*/ // her ,ikiside calışıyor
    return 0;
}





pointer denemesi char ve int
#include <stdio.h>
char *fuc(char *p1[],int size){
    printf("%d  %s\n",p1,p1[0]);
    return p1[size-1];// adres geri dönüyormuş
}
int fuc1(int *p){
return *p;
}
int main(){
    int size=1;
   char *p[7]={"monday","tuesday","wednesday","thursday","friday","saturday","sunday"};
   char *m=fuc(p,size);

   printf("%d %s\n",&m,m);
   printf("%d %s\n",p,p[0]);

    int arr[6];
    scanf("%d",arr+1);
    printf("%d %d\n",arr+1,*(arr+1));
    int *j;
    j=fuc1(arr+1);
    printf("%d %d\n",&j,j);
    return 0;
}





pointer char denemesi
input=ebru 35 yasinda
output=ebru 35 yasinda

#include <stdio.h>
#include <string.h>
int main()
{
   char *p;
   p="ebru 35 yasinda";
   int i=0;
   for(;*(p+i)!='\0';i++){
    printf("%c",*(p+i));
   }
    return 0;
}




array pointer denemesi
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main()
{
    int arr1[10];
    char arr2[10];

    printf("num\n");
    scanf("%d",arr1+2);


    arr1[6]=7;

    printf("*(arr1+%d)=%d\n",2,*(arr1+2));
    printf("arr1[%d]=%d\n",2,arr1[2]);

    printf("address of arr1[2]=%d\n",(int)&arr1[2]);
    printf("address of (arr1+2)=%d\n\n",(int)(arr1+2));

    printf("address of arr1=%d\n",(int)arr1);
    printf("address of arr1+2=%d\n",(int)arr1+2);
    printf("address of (arr1+2)=%d\n\n",(int)(arr1+2));

    printf("address of arr1[6]=%d and content of arr1[6]=%d\n",(int)&arr1[6],arr1[6]);
    printf("address of (arr1+6)=%d and content of *(arr1+6)=%d\n\n",(int)(arr1+6),arr1[6]);

    *arr2='b';
    arr2[4]='c';
    printf("char\n");
    scanf(" %c",arr2+2);
    printf("address of arr2+2=%ld and content of *(arr2+2)=%c\n",(long)(arr2+2),*(arr2+2));
    printf("address of arr2[2]=%ld and content of arr2[2]=%c\n\n",(long)&arr2[2],arr2[2]);

    printf("address of arr2[4]=%ld and content of arr2[4]=%c\n",(long)&arr2[4],arr2[4]);
    printf("address of (arr2+4)=%ld and content of *(arr2+4)=%c\n\n",(long)(arr2+4),*(arr2+4));

    printf("address of arr2[4]+2=%ld and content of arr2[4]+2=%c\n",(long)&arr2[4]+2,arr2[4]+2);
    printf("address of arr2+4+2=%ld and content of *(arr2+4)+2=%c\n\n",(long)arr2+4+2,*arr2+4+2);
/*
ilk olarak scanflerde sen bir boşluk bırakmazsan inci scanf'e hata verir,yani
scanf("%d",arr1+2);
scanf(" %c",arr2+2);
gördün mü "%d" ve " %c" bir boşluk var,boşluk sayısı fark etmez,
*/


    return 0;
}



structure denemesi;
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
struct exp{

int num;
char name1[12];
}n1;

typedef struct exp1{

char name[10];
struct exp n2;
}cha;


struct exp exp4(struct exp n4){
struct exp n5;
n5=n4;
printf("n5 name and n5 num\n");
scanf("%s %d",&n5.name1,&n5.num);
return n5;
}
/*
cha exp4(cha m1){
cha n4;
n4=m1;

return n4;
};
*/
int main()
{
    cha ch1={"ebru"};
    cha ch2;

    struct exp n3;
    strcpy(ch2.name,"yasmin");
    ch1.n2.num=31;
    printf("num of ch2.n2.num\n");
    scanf("%d ",&ch2.n2.num);

    printf("%s and %s\n",ch1.name,ch2.name);
    printf("%d and %d\n",ch1.n2.num,ch2.n2.num);
    n3.num=39;
    printf("fgets zamani name\n");
    fgets(n3.name1,12,stdin);
    printf("fget name=%s age=%d \n",n3.name1,n3.num);
    /*ch2=exp4(ch2);
    printf("new name of n2=%s and new age of n2=%d\n",ch2.name,ch2.n2.num);
    */
    n3=exp4(n3);
    printf("new name of n3=%s and new age of n3=%d\n",n3.name1,n3.num);

    return 0;
}



struct pointer denemesi
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
struct exp1{

char name[20];
int age;

}n1,*nptr;

struct exp1 degeral(struct exp1 *m1){

scanf("%s %d",m1->name,&(*m1).age);
printf("name =%s age=%d\n\n",(*nptr).name,nptr->age);
return *m1;
}
/*
void degeral(struct exp1 *m1){

scanf("%s %d",m1->name,&(*m1).age);

printf("name =%s age=%d\n\n",(*nptr).name,nptr->age);
}
*/
int main(){
nptr=&n1;
(*nptr).age=31;
//gets(nptr->name);
strcpy(nptr->name,"ebru , female");
printf("name =%s age=%d\n",(*nptr).name,nptr->age);
printf("first name and age\n\n");
scanf("%s %d",&n1.name,&nptr->age);
printf("name =%s age=%d\n\n",(*nptr).name,nptr->age);
printf("function ici name and age\n");
//degeral(nptr);
*nptr=degeral(nptr);
printf("function disi name and age\n");
printf("name =%s age=%d\n",(*nptr).name,nptr->age);
return 0;
}







lab2 question 6  pointer and structure are used.
#include <string.h>
#include <stdio.h>
struct fuc{
    char book[50];
};
void *fucc(struct fuc *m,struct fuc *m1){
     strcpy(m1->book,"C++ Programming");
     strcpy(m->book,"C Programming");
}
int main(){
    struct fuc booka,bookb;
    struct fuc *book1,*book2;
    book1=&booka;
    book2=&bookb;
    fucc(book1,book2);
    //strcpy(book1.book,"C Programming");
    //strcpy(book2.book,"C++ Programming");

    printf("%s\n%s",(*book1).book,book2->book);
    return 0;
}









lab3 question 3
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
struct exp{
  int feet;
  int inch;
};
void fuc(struct exp n1,struct exp n2,struct exp *dis){
    (*dis).feet=n1.feet+n2.feet;
    int i;
    i=n1.inch+n2.inch;
    while(i>=12){
        ++(*dis).feet;
        i-=12;
    }
    (*dis).inch=i;
}
int main(){
    struct exp fet,inc,dis3;

    scanf("%d%d",&fet.feet,&fet.inch);
    scanf(" %d%d",&inc.feet,&inc.inch);

    fuc(fet,inc,&dis3);
    printf("Sum of distances = %d\'-%d\"",(dis3).feet,(dis3).inch);

    return 0;
}




lab2 question 7 denemeler pointer scanf printf de yazma şekilleri
#include <stdio.h>
#include <stdlib.h>
struct person{
    int age;
    int weight;
};
int main(){
   int num,i;
   scanf("%d",&num);
    struct person  *p;
    p=(struct person*)malloc(num*sizeof(struct person));
    for(i=0;i<num;i++){
   scanf("%d%d",&(*(p+i)).age,&(p+i)->weight);
    }
    for(i=0;i<num;i++){
    printf("%d %d\n",p[i].age,(p+i)->weight);
    }

    // scanf (&p[i]).age, &(*(p+i)).age ,&(p+i)->age
    //printf  p[i].age,    (*(p+i)).age ,(p+i)->age
    return 0;
}







malloc realloc free deneme
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

int main(){
   int *p=(int*)malloc(2*sizeof(int)),i;
   for(i=0;i<2;i++){
   scanf("%d",&p[i]);
   }
   for(i=0;i<2;i++){
   printf("%d ",p[i]);
   }
   realloc(p,4*sizeof(int));
   printf("\npointer array is below the part after realloc\n");
   for(i=0;i<4;i++){
   scanf("%d",&p[i]);
   }
   for(i=0;i<4;i++){
   printf("%d ",p[i]);
   }
    free(p);
  // printf("%d",*(p+0);
    return 0;
}





link list deneme 
#include <stdio.h>
#include <stdlib.h>
 typedef struct n {
	
	int x;
	struct n*next;
	
}node;

int main(){
	node*root;
	root= (node*) malloc(sizeof(node));
	root->x=10;
	root ->next=(node*)malloc(sizeof(node));
	root->next->x=20;
	root->next->next=(node*)malloc(sizeof(node));
	root->next->next->x=30;
	node*iter;
	iter=root;
	printf("%d",iter->x);
	iter=iter->next;
	printf("\n%d",iter->x);
	return 0;
}



structure pointer felan deneme
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
typedef struct fuc{
    int book;
}man;
man *fu(man  *i){
     i[0].book=1213;
    (*(i+1)).book=1214;
    return i;
}
int main(){
    man s[2],*p;
    p=&s[0];
    p=fu(p);
   // p[0].book=1213;
    //(*(p+1)).book=1214;
    printf("%d\n%d",p[0].book,(p+1)->book);
    return 0;
}





structure pointer felan deneme
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
typedef struct fuc{
    char book[100];
}man;
man *fu(man  *i){
     strcpy(i[1].book,"C++ Programming");
     strcpy((i+1)->book,"C++ Programming");
    return i;
}
int main(){
    man s[2],*p;
    p=s;
    strcpy((*(p+0)).book,"C Programming");
    p=fu(p);
   // p[0].book=1213;
    //(*(p+1)).book=1214;
    printf("%s\n%s",p[0].book,(p+1)->book);
    return 0;
}





lab3 question 7 deneme

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct exp{
    int age;
    int weight;
}man;
int main(){
    int size,i;
    scanf("%d",&size);
    man *n1;
    n1=(man*)malloc(sizeof(man)*size);
    for(i=0;i<size;i++){
        scanf("%d%d",&n1[i].age,&(*(n1+i)).weight);
    }
    for(i=0;i<size;i++){
        printf("%d %d\n",n1[i].age,(*(n1+i)).weight);
    }
    //scanf("%d%d",&n1[i].age,&(n1+i)->weight);
    //printf("%d %d\n",n1[i].age,(n1+i)->weight);
    
    //scanf  &(*(n1+i)).weight
    //printf  (*(n1+i)).weight
    
    //scanf("%d%d",&(p+i)->age,&(p+i)->weight);
    //printf("%d %d\n",(p+i)->age,(p+i)->weight);
    
    //struct sız hali
   /* int *p,i,size,k;
    scanf("%d",&size);
    p=(int*)malloc(size*sizeof(int*));
    for(i=0;i<size;i++){
        for(k=0;k<2;k++){
        scanf("%d",&p[k]);
        printf("%d ",p[k]);
        }
        printf("\n");
    }
  */
    return 0;
}


lab4 question 3 deneme soruyu anlamak için bazı noktalara sayı verdim
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

typedef struct node {
	int val;
	struct node *next;

}Node;

void printlist(Node * headNode);
void function (Node * head, int a);

int main(){
	Node * head = NULL;
	head = malloc(sizeof(Node));
    int c=0;
	/*Set the value of head as 10*/
	head->val=10;

	/*Last node must point to NULL*/
	head->next=NULL;
    
    printf("   c=%d   \n",c);
	/*Set the value of last node as 20*/

    ++c;
    printf("  c=%d  ",c);
    function(head,20);
	/*print the list having two nodes with the value of 10 and 20 respectively*/
	printlist(head);

	/*Set the value of last node as 30*/
    ++c;
    printf("\n  c=%d  ",c);

    function(head,30);
	/*Set the value of last node as 40*/
    ++c;//3
    printf("  c=%d  ",c);

    function(head,40);
	/*Set the value of last node as 50*/
    ++c;//4
    printf("  c=%d  ",c);

    function(head,50);
    /*Set the value of last node as 60*/
    ++c;//5
    printf("  c=%d   ",c);

    function(head,60);
	/*print the list having six nodes with the value of 10, 20, 30, 40, 50 and 60 respectively*/
	printlist(head);

	return 0;
}

void printlist(Node * headNode){
	Node * iter;
	iter=headNode;

	while(iter !=NULL ){
		printf("%d ",iter->val);
		iter=iter->next;
	}
    printf("\n");
}

/*Complete the following function to add a new node to
the end of the list*/
void function (Node * head, int a) {
    Node *p = head;
    int b=0;

    while(p->next != NULL){
        p = p->next;
        b++;
        printf(" b={%d} ",b);
    }
    printf("\n");
    p->next=malloc(sizeof(Node));
    p->next->val=a;
    p->next->next=NULL;
}













double and single pointer denemesi
/*
#include <stdio.h>
void f(int **in) {
  (**in)++;
}
int main() {
  int i=5;
  //scanf("%d",&i);
  int *iPtr = &i;
  //int **jPtr= &iPtr;
  f(&iPtr);
  printf("%d", i);
  return 0;
}
*/







double and single pointer denemesi
#include <stdio.h>

// C program to demonstrate pointer to pointer
int main()
{
    int var = 789;

    // pointer for var
    int *ptr2;

    // double pointer for ptr2
    int **ptr1;

    // storing address of var in ptr2
    ptr2 = &var;

    // Storing address of ptr2 in ptr1
    ptr1 = &ptr2;

    // Displaying value of var using
    // both single and double pointers
    printf("Value of var = %d\n", var );
    printf("address of ptr2 using single pointer ptr2= %d\n", ptr2 );
    printf("address of ptr2 using double pointer *ptr1= %d\n", *ptr1);
    printf("Value of var using single pointer *ptr2= %d\n", *ptr2 );
    printf("Value of var using double pointer**ptr1 = %d\n", **ptr1);
  return 0;
}




deneme linkler
#include <stdio.h>
#include <stdlib.h>
typedef struct fuc{
int num;
struct fuc *next;
}man;

void bastir(man *m1){
while(m1!=NULL){
    printf("%d ",m1->num);
    m1=m1->next;
}
}

void yazdir(man *m1){
while(m1->next!=NULL){
    printf("%d ",m1->num);
    m1=m1->next;
}
}
int main(){
man *p,*iter;
int i=3;
p=(man*)malloc(sizeof(man));
p->num=10;
p->next=(man*)malloc(sizeof(man*));
p->next->num=20;
p->next->next=NULL;
iter=p;
while(iter->next!=NULL){
    printf("%d ",iter->num);
    iter=iter->next;
}
for(;i<6;i++){
    iter->next=(man*)malloc(sizeof(man));
    iter=iter->next;   //iter->next->num;
    iter->num=i*10;
    iter->next=NULL;
}
printf("\nbastir   m1!=NULL(p)\n");
bastir(p);
printf("\nyazdir (p)  m1->next!=NULL  \n");
yazdir(p);
return 0;
}





links ler deneme 2
#include <stdio.h>
#include <stdlib.h>

typedef struct n{
int x;
struct n *next;
}node;

void ekle (node *r, int x){

	while(r->next!=NULL){
	r=r->next;
	}
	r->next=(node*)malloc(sizeof(node));
	r->next->x=x;
	r->next->next= NULL;
}

void bastir(node *m1){
    while(m1!=NULL){
        printf("%d ",m1->x);
        m1=m1->next;
    }
}
int main(){

node *head;
head=(node*)malloc(sizeof(node));
head->next=NULL;
head->x=7;

node *iter;
iter=head;
int i=0;
for(i=0;i<5;i++){

	ekle(iter,i*10);
}
bastir(iter);
}





link deneme
output:
 0  while oncesi (*iter)=((12986736))
 1  while oncesi (*iter)=((12986752))
 2  while oncesi (*iter)=((12986768))
 3  while oncesi (*iter)=((12986784))
 4  while oncesi (*iter)=((12986800))
100 0 10 20 30 40

#include <stdio.h>
#include <stdlib.h>

typedef struct n{
int x;
struct n *next;
}node;

void ekle (node **r, int v){
    while((*r)->next!=NULL){
        (*r)=(*r)->next;
    }
    node *p;
    p=malloc(sizeof(node));
    p->x=v;
    p->next=NULL;
    //p->next=*r;
    (*r)-> next = p;
    *r=p;

    /*
	while((*r)->next!=NULL){
	(*r)=(*r)->next;
	printf(" while ici (*r)=[%d] ",(*r));
	}
	//printf(" [%d] ",v);
	(*r)->next=(node*)malloc(sizeof(node));
	(*r)->next->x=v;
	(*r)->next->next= NULL;
	*/
}

void bastir(node *m1){
    while(m1!=NULL){
        printf("%d ",m1->x);
        m1=m1->next;
    }
}
int main(){

node *head;
head=(node*)malloc(sizeof(node));
head->next=NULL;
head->x=100;

node *iter;
iter=head;
int i=0;
for(i=0;i<5;i++){
    printf(" %d  while oncesi (*iter)=((%d))    ",i,(iter));
	ekle(&iter,i*10);
	printf("\n");
}
/*
bastir(head);

bunu bu şekilde de yapabilirsin head adresi ilk yerinde 
iter adresi ise sürekli ekleme yaptıgın için en sonda kaldı 
bu sebeple ya iter in adresini tekrar başa alırsın yada head ile yazdırırsın
*/
iter=head;
bastir(iter);

}




link araya sayı ekleme denemesi


#include <stdio.h>
#include <stdlib.h>

typedef struct n{
int x;
struct n *next;
}node;

void ekle (node **r, int v){
    while((*r)->next!=NULL){
        (*r)=(*r)->next;
    }
    node *p;
    p=malloc(sizeof(node));
    p->x=v;
    p->next=NULL;
    //p->next=*r;
    (*r)-> next = p;
    *r=p;

    /*
	while((*r)->next!=NULL){
	(*r)=(*r)->next;
	printf(" while ici (*r)=[%d] ",(*r));
	}
	//printf(" [%d] ",v);
	(*r)->next=(node*)malloc(sizeof(node));
	(*r)->next->x=v;
	(*r)->next->next= NULL;
	*/
}

void bastir(node *m1){
    while(m1!=NULL){
        printf("%d ",m1->x);
        m1=m1->next;
    }
}
int main(){

node *head;
head=(node*)malloc(sizeof(node));
head->next=NULL;
head->x=100;

node *iter;
iter=head;
int i=0;
for(i=0;i<5;i++){
    printf(" %d  while oncesi (*iter)=((%d))    ",i,(iter));
	ekle(&iter,i*10);
	printf("\n");
}
/*
bastir(head);
bunu bu şekilde de yapabilirsin head adresi ilk yerinde
iter adresi ise sürekli ekleme yaptıgın için en sonda kaldı
bu sebeple ya iter in adresini tekrar başa alırsın yada head ile yazdırırsın
*/
iter=head;
bastir(iter);

//burdan sonra ekleme kısmı
for(i=0;i<3;i++){
    iter=iter->next;
}
node *temp;
temp=(node*)malloc(sizeof(node));
temp->x=25;
temp->next=iter->next;
iter->next=temp;
bastir(head);
return 0;
}








linkler deneme
0 4 40 50 400 450
#include<stdio.h>
#include<stdlib.h>
typedef struct n{
int v;
struct n *next;
}node;

void bastir(node *r){
while(r!=NULL){
      printf("%d ",r->v);
      r=r->next;
      }
}

node *ekle(node *r,int c){
    if(r==NULL){
        r=(node*)malloc(sizeof(node));
        r->next=NULL;
        r->v=c;
        return r;
    }
    if(r->v > c){
        node *temp=(node*)malloc(sizeof(node));
        temp->v=c;
        temp->next=r;
        return temp;
    }
    node *iter=r;
    while(iter->next!=NULL && iter->next->v < c){
        iter = iter->next;
    }
    node *temp;
    temp=(node*)malloc(sizeof(node));
    temp->next=iter->next;
    iter->next=temp;
    temp->v=c;
    return r;
}

int main(){
    node *root;
    root=NULL;
    root=ekle(root,400);
    root=ekle(root,40);
    root=ekle(root,4);
    root=ekle(root,450);
    root=ekle(root,50);
    root=ekle(root,0);
    bastir(root);


return 0;
}





/*
linklerle
output 
 10
 60 50 40 30 20 10 şeklinde yazdırıyor.
*/
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	int val;
	struct node *next;
	
}Node;

typedef Node* NodePtr;

void printList(Node * headNode);
void add_val_to_the_beginning(Node ** head, int a);

int main(){
	Node * head = NULL;
	head = malloc(sizeof(Node));
	/*Set the value of head as 10*/
	head->val=10;
	
	
	/*Last node must point to NULL*/
	(*head).next=NULL;
    

	/*print the list having one node with the value of 10*/
	printf("%d\n",(*head).val);
	
	/*Add a new element to the beginning of the list with value of 20*/
	add_val_to_the_beginning(&head,20);
	
	/*Add a new element to the beginning of the list with value of 30*/
	add_val_to_the_beginning(&head,30);
	
	/*Add a new element to the beginning of the list with value of 40*/
	add_val_to_the_beginning(&head,40);
	
	/*Add a new element to the beginning of the list with value of 50*/
	add_val_to_the_beginning(&head,50);
    
        /*Add a new element to the beginning of the list with value of 60*/
	add_val_to_the_beginning(&head,60);

	/*print the list having six nodes with the value of 60, 50, 40, 30, 20 and 10 respectively*/
	// alttaki 10 20 30 40 istiyorsan bu şekilde
	
        printList(head);
	return 0;
}

void printList(Node * headNode){
	Node * iter;
	iter=headNode;
		
	while(iter !=NULL ){		
		printf("%d ",iter->val);
		iter=iter->next;			
	}
    printf("\n");
}

/*Complete the following function to add a new node to
the beginning of the list*/
void add_val_to_the_beginning(Node ** head, int a) {
   Node *p;
   p=(Node*)malloc(sizeof(Node));
   (*p).val=a;
   p->next=*head;
   *head=p;    
}





/*
  linkler output;
   10 // bu 10 yukarıda başka bir printf var ordan
    10 20 30 40 50 60
   */


#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	int val;
	struct node *next;
	
}Node;

typedef Node* NodePtr;

void printList(Node * headNode);
void add_val_to_the_beginning(Node ** head, int a);

int main(){
	Node * head = NULL;
	head = malloc(sizeof(Node));
	/*Set the value of head as 10*/
	head->val=10;
	Node *m1;
	m1=head;
	
	/*Last node must point to NULL*/
	(*head).next=NULL;
    

	/*print the list having one node with the value of 10*/
	printf("%d\n",(*head).val);
	
	/*Add a new element to the beginning of the list with value of 20*/
	add_val_to_the_beginning(&head,20);
	
	/*Add a new element to the beginning of the list with value of 30*/
	add_val_to_the_beginning(&head,30);
	
	/*Add a new element to the beginning of the list with value of 40*/
	add_val_to_the_beginning(&head,40);
	
	/*Add a new element to the beginning of the list with value of 50*/
	add_val_to_the_beginning(&head,50);
    
    /*Add a new element to the beginning of the list with value of 60*/
	add_val_to_the_beginning(&head,60);

	/*print the list having six nodes with the value of 60, 50, 40, 30, 20 and 10 respectively*/
	
	printList(m1); 
	
   
	return 0;
}

void printList(Node * headNode){
	Node * iter;
	iter=headNode;
		
	while(iter !=NULL ){		
		printf("%d ",iter->val);
		iter=iter->next;			
	}
    printf("\n");
}

/*Complete the following function to add a new node to
the beginning of the list*/
void add_val_to_the_beginning(Node ** head, int a) {
   Node *p;
   p=(Node*)malloc(sizeof(Node));
   (*p).val=a;
   (*head) -> next=p;
   (*head)=p;      
}














/*
output
-78 0 4 40 50 89 400 450
*/
#include<stdio.h>
#include<stdlib.h>
typedef struct n{
int v;
struct n *next;
}node;

void bastir(node *r){
while(r!=NULL){
      printf("%d ",r->v);
      r=r->next;
      }
}

node *ekle(node *r,int c){
    if(r==NULL){
        r=(node*)malloc(sizeof(node));
        r->next=NULL;
        r->v=c;
        return r;
    }

    if(r->v > c){
        node *temp=(node*)malloc(sizeof(node));
        temp->v=c;
        temp->next=r;
        return temp;
    }
    node *iter=r;
    while(iter->next!=NULL && iter->next->v < c){
        iter = iter->next;
    }
    node *temp;
    temp=(node*)malloc(sizeof(node));
    temp->next=iter->next;
    iter->next=temp;
    temp->v=c;
    return r;
}

int main(){
    node *root;
    root=NULL;
    int i,arr[]={400,40,4,450,50,0,89,-78};
    for(i=0;i<8;i++){
        root=ekle(root,arr[i]);
    }
    bastir(root);
return 0;
}





2 tane link oluşturdum sonra sıralama yaptım 

array üzerinden söyle
arr= 10 30 50
arr1= 20 40 gibi 
ekledim sonra sıralamalı insert yaptım
temp adres=12200304
2temp adres=12200304
0 10 20 30 40 50

#include <stdio.h>
#include <stdlib.h>
typedef struct node{
    int num;
    struct node *next;
}oden;


void ekle(oden **m,int a){

    oden *m2;
    m2=(*m);

    while(m2->next!=NULL){
        m2=m2->next;

    }
    oden *m1;
    m1=(oden*)malloc(sizeof(oden));
    m1->num=a;
    m2->next=m1;
    m1->next=NULL;

}

oden *ekle1(oden*m,int a){
// first ,middle, last
oden *m1;
m1=m;

if(m1->num > a){
    oden *m2;
    m2=(oden*)malloc(sizeof(oden));
    m2->num=a;
    m2->next=m1;
    return m2;
}
while(m1->next!=NULL && m1->next->num <a){
    m1=m1->next;
}
oden *m3;
m3=(oden*)malloc(sizeof(oden));
m3->num=a;
m3->next=m1->next;
m1->next=m3;
return m;
}


void print(oden *m1){

    while(m1!=NULL){
        printf("%d ",m1->num);
        m1=m1->next;
    }
}
int main(){
   oden *head,*temp;
   int i,arr[4]={10,30,50},arr1[4]={20,40};
   head=(oden*)malloc(sizeof(oden));
   head->num=0;
   temp=head;
   head->next=NULL;
   for(i=0;i<2;i++){
    ekle(&temp,arr1[i]);
   }
   printf(" temp adres=%d \n",temp);
  // temp=head;
   printf("2temp adres=%d \n",temp);
   for(i=0;i<3;i++){
    temp=ekle1(temp,arr[i]);
   }

   print(head);
return 0;
}








/*
After adding new elements: 10 20 30 40 50 60
After removing last element: 10 20 30 40 50
*/
#include <stdio.h>
#include <stdlib.h>

typedef struct node {
	int val;
	struct node *next;

}Node;

typedef Node* NodePtr;

void printList(Node * headNode);
void add_val_to_the_beginning(Node ** head, int a);
void remove_last(Node **head,int a);

int main(){

    Node *alfa,* Head = NULL;
    /*Allocate memory for head node*/
    Head = malloc(sizeof(Node));
    /*Assign the value of head node as 10*/
    Head->val=10;
    alfa=Head;
    /*Head node is also the last node for now*/
    Head->next=NULL;

    add_val_to_the_beginning(&Head,20);
    add_val_to_the_beginning(&Head,30);
    add_val_to_the_beginning(&Head,40);
    add_val_to_the_beginning(&Head,50);
    add_val_to_the_beginning(&Head,60);

    printf("After adding new elements: ");
    printList(alfa);
    Head=alfa;
    int b=60;
    remove_last(&Head,b);
    printf("After removing last element: ");
    printList(alfa);

}
void printList(Node *headNode){
	Node * iter;
	iter=headNode;

	while(iter !=NULL ){
		printf("%d ",iter->val);
		iter=iter->next;
	}
    printf("\n");
}

void add_val_to_the_beginning(Node ** head, int a){

    NodePtr newNode;
    newNode=malloc(sizeof(Node));

    newNode->val=a;
    (*head)->next=newNode;
    newNode->next=NULL;
    *head=newNode;
}

void remove_last(Node **head,int a){
    Node  *p, *q;
    p = *head;

    /* if there is only one item in the list, remove it */
    if (p->val == a) {
        q=p->next;
        free(p);
        p=q;
    }
    else{

        /*Find the second last node*/
        while (p!=NULL && p->val != a)
        {
            q=p;
            p=p->next;
        }
        if(p->val==a){
           q->next=p->next;
            free(p);
        }
        else if(p->next==NULL){
            printf("no vaulues...\n");
        }

    }
}







concatenating  2 link 
the second one is concatenated to the end of first link
10 10 20 30 40
5 5 15 25 35 45

I did addition now lets concanate them

10 10 20 30 40 5 5 15 25 35 45

#include <stdio.h>
#include <stdlib.h>
typedef struct exp{
    int num;
    struct exp *next;
}roger;

void print(roger *head2){
    while(head2!=NULL){
        printf("%d ",head2->num/* (*head).num */);
        head2=head2->next;
    }
    printf("\n");
}

void add(roger **head1,int num1){

    roger *temp;

    if((*head1)==NULL){
        (*head1)=malloc(sizeof(roger));
        (*head1)->num=num1;
        (*head1)->next=NULL;
    }

     temp=(*head1);
    if(temp!=NULL){
        while(temp->next!=NULL){
            temp=temp->next;
        }
        roger *temp1;
        temp1=malloc(sizeof(roger));
        temp1->num=num1;
        temp1->next=NULL;
        temp->next=temp1;
    }
}

void conca(roger **m1,roger *n1){
    roger *temp3;
    temp3=(*m1);
    while(temp3->next!=NULL){
        temp3=temp3->next;
    }
    while(n1!=NULL){
        temp3->next=n1;
        n1=n1->next;
        temp3=temp3->next;
    }
}
int main(){
    roger *head,*headd,*temp;
    int i,arr1[5]={10,20,30,40},arr2[5]={5,15,25,35,45};
    head=(roger*)malloc(sizeof(roger));
    head=NULL;
    headd=(roger*)malloc(sizeof(roger));
    headd=NULL;

    for(i=0;i<4;i++){
        add(&head,arr1[i]);
    }
    for(i=0;i<5;i++){
        add(&headd,arr2[i]);
    }
    print(head);
    print(headd);
    printf("\nI did addition now lets concanate them\n\n");

    conca(&head,headd);
    print(head);

return 0;
}




input
i
l
k
j
output;
i l k j

#include <stdio.h>
#include <stdlib.h>

int main(){
    char *kar;
    int i;
    kar=(char*)calloc(1,10*sizeof(char*));
    scanf("%c",&*kar+0);
    scanf(" %c",&*kar+1);
    scanf(" %c",&*kar+2);
    scanf(" %c",&*kar+3);
    for(i=0;i<6;i++){
    printf("%c ",kar[i]);
    }
return 0;
}






#include <stdio.h>
#include <stdlib.h>

int main(){

    char *kar;
    int i;
    kar=(char*)malloc(10*sizeof(char));
    scanf("%s",&(*kar));

    printf("%s ",kar);


return 0;
}






sayı alıyorsun scanf den

#include <stdio.h>
#include <stdlib.h>

typedef struct exp{
    int num[10];
    struct exp *next;
}node;

void print(node *head2){
    int i=0;
    while(head2->num[i]!=NULL){
        printf("%d ",/*head2->num[i]*/(*head2).num[i] );
        i++;
    }
    printf("\n");
}

int main(){
    node *head;
    head=(node*)malloc(10*sizeof(node));
    head->next=NULL;
    int i;
    for(i=0;i<3;i++){
        scanf("%d",&(head)->num[i]);
    }
    print(head);


return 0;
}






karakter yazma linklerde

#include <stdio.h>
#include <stdlib.h>

typedef struct exp{
char name[10][10];
}man;

int main(){
int i;
man *ch;
ch=malloc(sizeof(man));
for(i=0;i<3;i++){
gets(ch->name[i]);
//scanf("%s",&(ch)->name);
printf("%s\n",ch->name[i]);
}
return 0;
}











2 inci ödev
10 20 30 40
5 15 25 35 45

I did addition now lets concanate them

10 20 30 40 5 15 25 35 45

I did the concatenation now let's do sorting (ascending)

5 10 15 20 25 30 35 40 45

#include <stdio.h>
#include <stdlib.h>
typedef struct exp{
    int num;
    struct exp *next;
}roger;

void print(roger *head2){
    while(head2!=NULL){
        printf("%d ",head2->num/* (*head).num */);
        head2=head2->next;
    }
    printf("\n");
}

void add(roger **head1,int num1){

    roger *temp;

    if((*head1)==NULL){
        (*head1)=malloc(sizeof(roger));
        (*head1)->num=num1;
        (*head1)->next=NULL;
    }
    else{
     temp=(*head1);
    if(temp!=NULL){
        while(temp->next!=NULL){
            temp=temp->next;
        }
        roger *temp1;
        temp1=malloc(sizeof(roger));
        temp1->num=num1;
        temp1->next=NULL;
        temp->next=temp1;
    }
    }
}

void conca(roger **m1,roger *n1){
    roger *temp1;
    temp1=(*m1);
    while(temp1->next!=NULL){
        temp1=temp1->next;
    }
    while(n1!=NULL){
        temp1->next=n1;
        n1=n1->next;
        temp1=temp1->next;
    }
}

void sort(roger **m2){


    roger *temp1,*temp2,*temp3,*temp4;
    temp4=malloc(4*sizeof(roger));

    temp1=(*m2);
    temp2=(*m2)->next;
    temp3=(*m2);
    while(temp3!=NULL){


        while(temp1!=NULL){

            if(temp2!=NULL){
                //printf(" (3) ");

                if(temp1->num > temp2->num){
                        //printf(" (4) ");
                    temp4->num=temp2->num;
                    temp2->num=temp1->num;
                    temp1->num=temp4->num;
                }
            }
               // printf(" (5) ");
               if(temp2->next!=NULL){
                temp2=temp2->next;

               }
               temp1=temp1->next;
        }

    temp3=temp3->next;
    temp1=(*m2);
    temp2=(*m2)->next;

    }
}

int main(){
    roger *head,*headd,*temp;
    int i,arr1[5]={10,20,30,40},arr2[5]={5,15,25,35,45};
    head=(roger*)malloc(sizeof(roger));
    head=NULL;
    headd=(roger*)malloc(sizeof(roger));
    headd=NULL;

    for(i=0;i<4;i++){
        add(&head,arr1[i]);
    }
    for(i=0;i<5;i++){
        add(&headd,arr2[i]);
    }
    print(head);
    print(headd);
    printf("\nI did addition now lets concanate them\n\n");

    conca(&head,headd);
    print(head);

    printf("\nI did the concatenation now let's do sorting (ascending)\n\n");

    sort(&head);
    print(head);

    free(head);
    free(headd);
return 0;
}





sıralı bir şekilde link yapma

input=40,20,44,400,50
output=20 44 50 400

#include <stdio.h>
#include <stdlib.h>
typedef struct exp{
    int num;
    struct exp *next;
}oden;

void print(oden *head2){
    while(head2!=NULL){
        printf("%d ",head2->num);
        head2=head2->next;
    }
    printf("\n");
}

void add(oden **m1,int num1){
    oden *newp,*pre,*cur;
    newp=malloc(sizeof(oden));
    if(newp !=NULL){
        newp->num=num1;
        newp->next=NULL;

        cur=(*m1);
        pre=NULL;

        while(cur !=NULL && cur->num < num1){
            pre=cur;
            cur=cur->next;
        }
        if(pre==NULL){
            newp->next=(*m1);
            (*m1)=newp;
        }
        else{
           pre->next=newp;
            newp->next=cur;
        }

    }


}


int main(){
    oden *head;
    head=NULL;
    int arr[10]={40,20,44,400,50},i;

    for(i=0;i<5;i++){
        add(&head,arr[i]);

    }

    print(head);

return 0;
}








2 tane link i yaratma ve  sıralama
head
20 40 44 50 400
m1
25 35 43 45 58

head
20 25 35 40 43 44 45 50 58 400

#include <stdio.h>
#include <stdlib.h>
typedef struct exp{
    int num;
    struct exp *next;
}oden;

void print(oden *head2){
    while(head2!=NULL){
        printf("%d ",head2->num);
        head2=head2->next;
    }
    printf("\n");
}

void add(oden **m1,int num1){
    oden *newp,*pre,*cur;
    newp=malloc(sizeof(oden));
    if(newp !=NULL){
        newp->num=num1;
        newp->next=NULL;

        cur=(*m1);
        pre=NULL;

        while(cur !=NULL && cur->num < num1){
            pre=cur;
            cur=cur->next;
        }
        if(pre==NULL){
            newp->next=(*m1);
            (*m1)=newp;
        }
        else{
            oden *p;
            p=cur;
            pre->next=newp;
            newp->next=p;
        }
    }
}

void sort(oden **m1,oden *m2){

    while(m2!=NULL){
    oden *newp,*cur,*pre;;
    newp=malloc(sizeof(oden));
    newp->num=m2->num;
    cur=(*m1);
    pre=NULL;
    while(cur!=NULL && cur->num < newp->num){
        pre=cur;
        cur=cur->next;
    }
    if(pre==NULL){
       newp->next=cur;
       (*m1)=newp;
    }
    if(cur->num >= newp->num){
        newp->next=pre->next;
        pre->next=newp;

    }
    m2=m2->next;
    }
}
int main(){
    oden *head;
    oden *m1;
    m1=NULL;
    head=NULL;
    int arr[10]={40,20,44,400,50},i;
    int ar[10]={35,25,43,45,58};
    for(i=0;i<5;i++){
        add(&head,arr[i]);
        add(&m1,ar[i]);
    }
    printf("head\n");
    print(head);
    printf("m1\n");
    print(m1);

    sort(&head,m1);

    printf("\nhead\n");
    print(head);

return 0;
}




head
20 40 44 50 400
NULL
m1
25 35 43 45 58
NULL

head
20 25 35 40 43 44 45 50 58 400
NULL
m1

NULL

hocanın verdigi 3 üncü ödev
#include <stdio.h>
#include <stdlib.h>
typedef struct exp{
    int num;
    struct exp *next;
}oden;

void print(oden *head2){
    while(head2!=NULL){
        printf("%d ",head2->num);
        head2=head2->next;
    }
    if(head2==NULL){
            printf("\nNULL");
        }
    printf("\n");
}

void add(oden **m1,int num1){
    oden *newp,*pre,*cur;
    newp=malloc(sizeof(oden));
    if(newp !=NULL){
        newp->num=num1;
        newp->next=NULL;

        cur=(*m1);
        pre=NULL;

        while(cur !=NULL && cur->num < num1){
            pre=cur;
            cur=cur->next;
        }
        if(pre==NULL){
            newp->next=(*m1);
            (*m1)=newp;
        }
        else{
            oden *p;
            p=cur;
            pre->next=newp;
            newp->next=p;
        }
    }
}

void sort(oden **m1,oden **m2){
    oden *temp;

    while((*m2)!=NULL){
    oden *newp,*cur,*pre;;
    newp=malloc(sizeof(oden));
    newp->num=(*m2)->num;
    cur=(*m1);
    pre=NULL;
    while(cur!=NULL && cur->num < newp->num){
        pre=cur;
        cur=cur->next;
    }
    if(pre==NULL){
       newp->next=cur;
       (*m1)=newp;
    }
    if(cur->num >= newp->num){
        newp->next=pre->next;
        pre->next=newp;

    }
    temp=(*m2)->next;
    free(*m2);
    (*m2)=temp;

    }
}
int main(){
    oden *head;
    oden *m1;
    m1=NULL;
    head=NULL;
    int arr[10]={40,20,44,400,50},i;
    int ar[10]={35,25,43,45,58};
    for(i=0;i<5;i++){
        add(&head,arr[i]);
        add(&m1,ar[i]);
    }
    printf("head\n");
    print(head);
    printf("m1\n");
    print(m1);

    sort(&head,&m1);

    printf("\nhead\n");
    print(head);
    printf("m1\n");
    print(m1);

return 0;
}






hocanın derste şu charlarda enter ve delete kodu ,
yalnız enter isim  yazıp ekliyoruz 
delete isim yazınca siliyor (silme kısmı tam degil ne isim yazarsan yaz
hep 0 inci yerdekini siler mesele ilkay girdin sonra ebru sonra esma dedin 
delete ebru desen bile gider ilkay ı siler .
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX_SIZE  100

typedef struct node{
	char name[30];
	struct node *next;
}_QNODE;
typedef struct {
	_QNODE *queue_front, *queue_rear;
}_QUEUE;



_QNODE *enqueue(_QUEUE *q, char x[]){
	_QNODE *temp;
	temp= (_QNODE *) malloc (sizeof(_QNODE));
	if (temp==NULL){
		printf("Bad allocation \n");
		return NULL;
	}
	strcpy(temp->name,x);
	temp->next=NULL;
	if(q->queue_rear==NULL){
		q->queue_rear=temp;
		q->queue_front=q->queue_rear;
	}else{
		q->queue_rear->next=temp;
		q->queue_rear=temp;
	}
	return(q->queue_rear);
}

char  *dequeue(_QUEUE *q,char x[])
{
	_QNODE *temp_pnt;
	if(q->queue_front==NULL){
		q->queue_rear=NULL;
		printf("Queue is empty \n");
		return(NULL);
	}else{
		strcpy(x,q->queue_front->name);
		temp_pnt=q->queue_front;
		q->queue_front=q->queue_front->next;
		free(temp_pnt);
		if(q->queue_front==NULL)
			q->queue_rear=NULL;
		return(x);
	}
}

void init_queue(_QUEUE *q){
	q->queue_front= q->queue_rear=NULL;
}

int isEmpty(_QUEUE *q){
	if(q==NULL)
		return 1;
	else
		return 0;
}

int main()
{
	int i,j;
	char command[5],val[30];
	_QUEUE q;
	init_queue(&q);
	command[0]='\0';
	printf("For entering a name use 'enter <name>'\n");
	printf("For  deleting  use 'delete' \n");
	printf("To end the session use 'bye' \n");

	while(strcmp(command,"bye")){
		scanf("%s",command);
		if(!strcmp(command,"enter")) {
			scanf("%s",val);
			printf("Name entered %s \n",val);
			enqueue(&q,val);
		}
		if(!strcmp(command,"delete")) {
			if(isEmpty(&q))
				printf("Cannot delete, queue is empty!");
			else
				printf("Deleted val: %s \n",dequeue(&q,val));

		}
	} /* while */

	printf("End session \n");
	return 0;
}




lab7 question 2
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
// fifo yapacagım.
/*
add CSE1146
add Intermediate
add Programming
bye

For adding a name use 'add [name]'
For deleting  use 'delete'
To end the session use 'bye'
inserted: CSE1146
inserted: Intermediate
inserted: Programming
End session
*/

typedef struct {
    char name[100];
}oden;
typedef struct {
    oden arr[100];
    int front;
    int rear;
    int full;
    int empty;
}initial;

void init(initial *q){
    q->front=q->rear=0;
    q->full=0;
    q->empty=1;
}

void add(oden q,initial *p){
    if(p->full){
        printf("no way1");
        return ;
    }
    p->rear++;
    p->arr[p->rear]=q;
    if(p->rear==p->front){
        p->full=1;
    }else{
        p->full=0;
    }
     p->empty=0;
}

oden del(initial *n){
    oden temp;
    if(n->empty){
        printf("no way 2");
        return ;
    }
    n->front++;
    temp=n->arr[n->front];
    if(n->front==n->rear){
        n->empty=1;
    }else{
        n->empty=0;
    }
    n->full=0;
return temp;
}
int main(){
    char command[100];
    oden st1;
    initial m1;
    init(&m1);
    command[0]='\0';
    printf("For adding a name use 'add [name]'\n");
	printf("For deleting  use 'delete' \n");
	printf("To end the session use 'bye' \n");
    while(strcmp(command,"bye")!=0){
        scanf("%s",command);
        if(strcmp(command,"add")==0){
            scanf("%s",st1.name);
            if(m1.full){
                printf("no space\n");
            }else{
                add(st1,&m1);
                printf("added  %s \n",st1.name);
            }
        }
        if(strcmp(command,"delete")==0){

            if(m1.empty){
                printf("no way\n");
            }else{
                st1=del(&m1);
                printf("deleted %s \n",st1.name);
            }
        }
    }
    printf("end session\n");
return 0;
}







lab7 question 5 
isimleri farklı anlaşılır 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct node{
    char name[30];
    int prio;
    struct node *next;
}first;

typedef struct{
    first *front;
    first *rear;
}second;

first *add(second *q,char x[],int pri){
    first *temp;
    temp=malloc(sizeof(first));
    if(temp==NULL){
        printf("Bad allocation \n");
		return NULL;
    }
    strcpy(temp->name,x);
    temp->next=NULL;
    temp->prio=pri;

    if(q->rear==NULL){
        q->rear=temp;
        q->front=q->rear;
    }else{
        first *cur=q->front;
        first *pre=NULL;
        while((cur->prio <=pri)&&(cur->next!=NULL)){
            pre=cur;
            cur=cur->next;
        }
        if(cur==q->rear && cur== q->front){
            if(q->rear->prio <=temp->prio){
                q->rear->next=temp;
                q->rear=q->rear->next;
            }else{
            q->front=temp;
            q->front->next=q->rear;
            }
        }
        else if(cur==q->rear){
            if(q->rear->prio <= temp->prio){
                q->rear->next=temp;
                q->rear=temp;
            }else{
                pre->next=temp;
                temp->next=cur;
            }
        }
        else if(cur==q->front){
            temp->next=q->front;
            q->front=temp;
        }else{
            pre->next=temp;
            temp->next=cur;
        }
    }
}

char *del(second *q,char x[]){
    first *temp;
    if(q->front==NULL){
        q->rear=NULL;
        return NULL;
    }else{
        strcpy(x,q->front->name);
        temp=q->front;
        q->front=q->front->next;
        free(temp);
        if(q->front==NULL){
            q->rear=NULL;
        }
        return x;
    }
}

void init(second *q){
q->front= q->rear= NULL;
}

int emp(second *q){
    if(q=NULL){
        return 1;
    }else{
    return 0;
    }
}

int main(){
    char command[10],val[30];
    second q;
    init(&q);
    command[0]='\0';
    int num;
    // bye den sonra !=0 yapmadık
    while(strcmp(command,"bye")!=0){
        scanf("%s",command);
        if(!strcmp(command,"add")){
            scanf("%s",val);
			scanf("%d",&num);
			if((add(&q,val,num)==NULL)){
                printf("no more...");
			}else{
			printf("name:%s priority: %d \n",val,num);
			}
        }
        if(!strcmp(command,"delete")){
            if(!emp(&q)){
                printf("deleted name:%s \n",del(&q,val));
            }else{
                printf("queue is empty\n");
            }
        }

    }
printf("end session \n");
return 0;
}



mid term 2019 sorusu hoca koymuş
question;
In this question, you should implement “countLetters” function and complete the 
function call in the main program. The main program is already given. 
Characters are read from the user until a ‘%’ character is entered and 
characters are stored in an array named ‘arr’. 
The size of the array is stored in a variable named ‘size’. 
Your function should count the lowercase characters in the array and 
store the result in “numOfLower” variable, 
and count the uppercase characters in the array and 
store the result in “numOfUpper” variable.

Input	         Result
G4!gAasdf4%      5 2
123456789%       0 0

#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 100
/*give the correct parameters for the function prototype*/
void countLetters(char arr[],int size,int *low,int *up);

int main(){
    char arr[MAX_SIZE], ch;
    int size = 0, numOfLower=0, numOfUpper=0;
    /* read the characters to array */
    scanf("%c",&ch);
    while (ch != '%') {
    	arr[size] = ch;
    	size++;
    	scanf("%c",&ch);
    }
    countLetters(arr, size, &numOfLower, &numOfUpper);
    /* print results */
    printf("%d %d\n", numOfLower, numOfUpper);
    return 0;
}
/*Function has no return, do not change the return type, do not return anything!*/
void countLetters(char arr[],int size,int *low,int *up){
    int i;
    for(i=0;i<size;i++){
        if(arr[i]<123 && arr[i]>96){
            (*low)++;
        }
        if(arr[i]<91 && arr[i]>64){
            (*up)++;
        }
    }
}





hocanın 2019 sınavında sordugu başka soru
Write a C function named void getOddNumbers( FILE* fpRead, FILE* fpWrite) 
which reads a text file line by line and print odd numbers from that 
file to a second file.Use fgets and fprintf for reading and writing. 
Here, assume the files are already opened in read and write modes and return 
values of fopen are assigned to fpRead and fpWrite respectively . 
Test	                          Input	        Result
getOddNumbers( stdin, stdout);    123           123
                                  456

void getOddNumbers( FILE* fpRead, FILE* fpWrite){
  char buffer[255];
  if(fpRead == NULL || fpWrite == NULL){
    /*printf("Error opening file\n");*/
  }else{
    /*printf("File opened successfully.\n");*/
    
    while(fgets(buffer, 255, fpRead)) {
        int number = atoi(buffer);
        if(number%2==1){
            fprintf(fpWrite, "%d\n", number);
        }
    }

    fclose(fpRead);
    fclose(fpWrite);
    }
}








hocanın 2020 sınav sorusu son soru;
soru;
In this question you will add Person information (name, surname) to the two dimensional 
(2D) sorted (i.e. in lexicographical order) linked list. You will dynamically allocate 
each node when user enters 'insert <name> <surname>' or free the corresponding node when 
user enters 'delete <name> <surname>'Names will be first dimension order, 
if a person with the same name added to the linked list, surname will sort the second 
dimension. You can assume all inputs will be valid, there is no such 'enter <name>' cases.
 You must have 2 pointers in your struct to be able to link in 2D. You can call them 
next and sibling. print command will print the current status of the 2D linked list, 
where each line represents the first dimension, and the 2nd dimension elements are 
separated on the same line using arrow, ->.

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct node {
	char* name;
	char* surname;
	struct node *next;
	struct node *sibling;
} Node;

typedef Node* NodePtr;

void printList(Node * headNode);
void insert(Node **sPtr, char name[], char surname[]);
void freeNode(Node * nd);
int delete(Node **sPtr, char name[], char surname[]);
int main() {
	Node * Head = NULL;

	char command[10], name_val[30], surname_val[30];
	command[0] = '\0';
	while (strcmp(command, "bye")) {
		scanf("%s", command);

		if (!strcmp(command, "insert")) {
			scanf("%s", name_val);
			scanf("%s", surname_val);
			insert(&Head, name_val, surname_val);
			printf("Name inserted %s %s \n", name_val, surname_val);
		}
		if (!strcmp(command, "delete")) {
			scanf("%s", name_val);
			scanf("%s", surname_val);
			if (delete(&Head, name_val, surname_val))
				printf("Person deleted %s %s \n", name_val, surname_val);
		}
		if (!strcmp(command, "print")) {
			printList(Head);

		}
	} /* while */

	printf("End session \n");
	return 0;
}


void printList(Node * headNode) {
	Node * iter;
	iter = headNode;

	while (iter != NULL) {

		Node *siter;
		siter = iter;
		while (siter != NULL) {
			printf("%s %s", siter->name, siter->surname);
		    if(siter->sibling!=NULL)
            printf("->");
			siter = siter->sibling;
		}
		printf("\n");
		iter = iter->next;
	}
}
void freeNode(Node * nd) {
	free(nd->name);
	free(nd->surname);
}
void insert(Node **sPtr, char name[], char surname[]) {
	NodePtr newPtr;
	NodePtr previousPtr;
	NodePtr currentPtr;

	newPtr = malloc(sizeof(Node));
	newPtr->name = (char*) malloc(strlen(name) * sizeof(char));
	newPtr->surname = (char*) malloc(strlen(surname) * sizeof(char));
	if (newPtr != NULL) {

		strcpy(newPtr->name, name);
		strcpy(newPtr->surname, surname);
		newPtr->next = NULL;
		newPtr->sibling = NULL;

		currentPtr = *sPtr;
		previousPtr = NULL;

		while (currentPtr != NULL && strcmp(name, currentPtr->name) > 0) {
			previousPtr = currentPtr;
			currentPtr = currentPtr->next;
		}  //we arrived the true name node (first dimension)
		if (currentPtr != NULL && strcmp(name, currentPtr->name) == 0) {
			// same name, add to sibling as surname ascending
			// traverse in surname, add to second dimension
			while (currentPtr != NULL
					&& strcmp(surname, currentPtr->surname) > 0) {
				previousPtr = currentPtr;
				currentPtr = currentPtr->sibling;
			}
			if (previousPtr != NULL) {
				if(previousPtr->sibling==currentPtr){
					previousPtr->sibling = newPtr;
					newPtr->sibling = currentPtr;
				}else{//previousPtr->next==currentPtr
					newPtr->sibling=currentPtr;
					newPtr->next=currentPtr->next;
					currentPtr->next=NULL;
					previousPtr->next=newPtr;
				}
			} else { // previous NULL,add to the first in name order
				newPtr->next = currentPtr->next;
				currentPtr->next = NULL;
				newPtr->sibling = currentPtr;
				*sPtr = newPtr;
			}
		} else {
			//insert new node at the beginning of list
			// name does not exist add to first dimension
			if (previousPtr == NULL) {
				newPtr->next = *sPtr;
				*sPtr = newPtr;
			} else {
				previousPtr->next = newPtr;
				newPtr->next = currentPtr;
			}
		}

	} else
		printf("%s%s not inserted. No memory available.\n", name, surname);
}
int delete(Node **sPtr, char name[], char surname[]) {
	NodePtr previousPtr = NULL;
	NodePtr currentPtr;
	currentPtr = *sPtr;
	if (currentPtr == NULL) {
		printf("List is empty \n");
		return (0);
	} else {
		while (currentPtr != NULL && strcmp(name, currentPtr->name) > 0) {
			previousPtr = currentPtr;
			currentPtr = currentPtr->next;
		}
		if (currentPtr == NULL) {
			printf("Person is not found \n");
			return (0);
		} else { // name found look for surname
			if (strcmp(surname, currentPtr->surname) == 0) { // first name node to be deleted
				if (currentPtr->sibling != NULL) {
					if (previousPtr != NULL) {
						previousPtr->next = currentPtr->sibling;
						currentPtr->sibling->next = currentPtr->next;
						freeNode(currentPtr);
						return (1);
					} else { // previousPtr == NULL
						// Deleting first node of name and first node of surname
						if (currentPtr->sibling == NULL) {
							*sPtr = currentPtr->next;
							freeNode(currentPtr);
							return (1);
						} else {
							currentPtr->sibling->next = currentPtr->next;
							*sPtr = currentPtr->sibling;
							freeNode(currentPtr);
							return (1);
						}

					}

				} else {
					if(previousPtr!=NULL){
					previousPtr->next = currentPtr->next;
					freeNode(currentPtr);
					return (1);
					}
					else{
						*sPtr = currentPtr->next;
						freeNode(currentPtr);
						return (1);
					}
				}
			} else {
				while (currentPtr != NULL
						&& strcmp(surname, currentPtr->surname) > 0) {
					previousPtr = currentPtr;
					currentPtr = currentPtr->sibling;
				}
				if (currentPtr != NULL
						&& strcmp(surname, currentPtr->surname) == 0) {
					previousPtr->sibling = currentPtr->sibling;
					freeNode(currentPtr);
					return (1);
				} else {
					printf("Person is not found \n");
					return (0);
				}

			}
		}
	}
}


2020 sınav sorusu hocanın
Complete the following C program that reads the ages of N students one by one from 
the console and finds those that are below the average.

Input	          Result
4 10 20 30 40     10 20

#include <stdio.h>
#include <stdlib.h>

int main()
{
    int i,N, sum=0;
    int *ageArr;
    float avg;

    /*Read the number of students*/
    scanf("%d", &N);
  
    /*Allocate a block of memory for N ages using malloc*/
    ageArr = (int *)malloc(N * sizeof(int));
    
    /*Read ages one by one from the console and calculate sum*/
    for (i=0; i<N; i++){
        scanf("%d", &ageArr[i]);
        sum += ageArr[i];
    }
    
    /*Calculate the average age*/
    avg = sum / (float) N;    

    /*Print the ages below the average*/
    for(i=0;i<N;i++)
        if (ageArr[i]<avg)
            printf("%d ",ageArr[i]);
     printf("\n");
    
    /*Deallocate memory*/ 
    free (ageArr);
    return 0;
}







hocanınc sınav sorusu 2020
Write a C function named void convertUpperCase( FILE* fpRead, FILE* fpWrite) 
which reads a text file line by line and convert all characters in upper case and 
write them to a second file. You can use fgetc, fgets and fprintf for reading and 
writing. Here, assume the files are already opened in read and write modes and return 
values of fopen are assigned to fpRead and fpWrite respectively . 
Test	                                   	
convertUpperCase( stdin, stdout);         
Input
123abCd.efGts!!.. asdettrtuaoaPo
mmmmmmmmsss ssss EE345aaaaaa bbbb   
Result                          
123ABCD.EFGTS!!.. ASDETTRTUAOAPO
MMMMMMMMSSS SSSS EE345AAAAAA BBBB


void convertUpperCase( FILE* fpRead, FILE* fpWrite){
  char ch;
  if(fpRead == NULL || fpWrite == NULL){
    /*printf("Error opening file\n");*/
  }else{
    /*printf("File opened successfully.\n");*/
    
        while((ch=fgetc(fpRead))!=EOF){
            
            if ('a'<=ch && ch<='z')
                ch+='A' -'a';
            fprintf(fpWrite, "%c", ch);
        }
    
        fclose(fpRead);
        fclose(fpWrite);
    }
}







üstteki soruyu kendi yöntemimle yaptım char array ini bir bütün olarak aldım

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
int main(){
int i,j,size=0,len[50],k;
char ch[10][50],temp[50];
char ch1[5][20]={"asdfgw","qwertas","zxcvbdsa"};
FILE *pr=fopen("sınav.txt","r");
FILE *pw=fopen("exam.txt","w");


if(pr!=NULL){
}else{
    for(i=0;i<3;i++){
    fprintf(pr,"%s\n",ch1[i]);
    }
}

i=0;
while(fgets(temp,200,pr)){
        strcpy(ch[i],temp);
        //printf("%s",ch[i]);
        len[i]=strlen(temp);
        //printf("\nlen: %d\n",len[i]);
        i++;
        size++;

}
//printf("\nsize: %d\n",size);
for(i=0;i<size;i++){
    for(j=0;j<len[i];j++){
        if(ch[i][j]<96 && ch[i][j] >123 ){
        continue;
        }else if(ch[i][j]=='\n'){
            break;
        }else{
        ch[i][j]=ch[i][j]-32;
        }
    }
}
for(i=0;i<size;i++){
    fprintf(pw,"%s\n",ch[i]);
    //fputs(ch[i],pw);
}
    return 0;
}



#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*
int main(){
   int arr[10];
   scanf("%d",arr+0);
   scanf("%d",&arr[1]);
   printf("%d %d",*arr,arr[1]);
*/

   /* int x[10],*p1;
    char ch[20],*p;
    p=ch;
    int i;
    p1=&x;
    for(i=0;i<3;i++){
    scanf("%d",(p1+i));
    }
    for(i=0;i<3;i++){
    printf("%d\n",*(p1+i));
    }

    scanf("%s",p);
    printf("%s",p);

    float n,*p2;
    p2=&n;
    scanf("%f",p2);
    printf("%.1f",*p2);
    return 0;
}
    */




#include <stdio.h>
#include <stdlib.h>
#include <string.h>
typedef struct x{
    int num;
    char ch[100];
}man;
void fuc(man *m){
    man *p;
    p=m;
    scanf("%d%s",&p->num,&(*p).ch);
    printf("%d\n%s\n",p->num,p->ch);
    return m;
}

int main(){
    man m,*p;
    p=&m;
    fuc(p);
    printf("%d\n%s",p->num,(*p).ch);
    return 0;
}







#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int fuc1(int *m){
    *m=5;
    return m;
}
char *fuc2(char *m){
    m='L';
    return m;
}
int fuc3(int *arr){
arr[2]=3;
arr[1]=2;
return arr;
}
char *fuc4(char *arr1){
    arr1[2]='A';
    arr1[1]='b';
    return arr1;
}
void fuc5(int *ap,char **bp,int *arr1,char *arr2){
    *ap=1;
    *bp='m';
    *(arr1+1)=10;
    arr1[2]=20;
    *(arr2+2)='n';
    arr2[1]='a';
    arr2[1]=arr2[1]+1;

}
int main(){
int a,arr[10],*ap,*arr1;
char b,ch[10],*bp,*arr2;
arr1=arr;
arr2=ch;
ap=&a;
bp=&b;
ap=fuc1(ap);
printf("ap=%d\n",*ap);
bp=fuc2(bp);
printf("character %c\n",bp);
fuc3(arr1);
printf("arr1=%d\n",arr1[2]);
printf("arr1=%d\n",arr1[1]);
arr2=fuc4(arr2);
printf("arr2=%c\n",arr2[2]);
printf("arr2=%c\n",*(arr2+1)+1);

printf("\n\nhepsi bir arada \n \n");

fuc5(ap,&bp,arr1,arr2);
printf("ap=%d\n",*ap);
printf("character %c\n",bp);
printf("arr1=%d\n",arr1[2]);
printf("arr1=%d\n",arr1[1]);
printf("arr2=%c\n",arr2[2]);
printf("arr2=%c\n",*(arr2+1)+1);

printf("\n\naddress time \n\n");

printf("address %d\n",(ap));
printf("address %d\n",(int)(bp));
printf("address arr1[0] %d\n",(arr1[0]));
printf("address *(arr1+1) %d\n\n",(arr1+1));

printf("address arr2[0] %d\n",(int)(arr2));
printf("address arr2[1] %d\n",(int)(arr2+1));
printf("address *(arr2+2) %d\n",(int)(arr2+2));

return 0;
}






lab7 question 4
bu soruda deletion da denemeler yaptım 
pointer struct,normal struct ve char array
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct a{
    char name[30];
    struct a *next;
}man;
typedef struct b{
    man *front,*rear;
}oden;

void add(oden *q,char x[]){
    man *temp;
    temp=(man*)malloc(sizeof(man));
    if(temp==NULL){
        printf("null\n");
        return;
    }
    strcpy(temp->name,x);
    if(q->rear==NULL){
        q->rear=q->front=temp;
    }else{
        q->rear->next=temp;
        q->rear=temp;
    }
}
man *del(oden *q,man *x){
    if(q->front==NULL){
        exit(-1);
    }else{
        man *temp;
        strcpy(x->name,q->front->name);
        temp=q->front;
        q->front=q->front->next;
        free(temp);
        return x;
    }
}
/*
man del(oden *q,man x){
    if(q->front==NULL){
        exit(-1);
    }else{
        man *temp;
        strcpy(x.name,q->front->name);
        temp=q->front;
        q->front=q->front->next;
        free(temp);
        return x;
    }
}
*/
/*
char *del(oden *q,char x[]){
    if(q->front==NULL){
        exit(-1);
    }else{
        man *temp;
        strcpy(x,q->front->name);
        temp=q->front;
        q->front=q->front->next;
        free(temp);
        return x;
    }
}
*/
int emp(oden *q){
    if(q==NULL){
        return 0;
    }
    return 1;
}
int main(){
    oden head;
    head.front=head.rear=NULL;
    char com[30],val[30];
    com[0]='\0';
    //man x; şu function dan döndürmede pointersiz
    man *x;
    x=malloc(sizeof(man));
	printf("For entering a name use 'enter <name>'\n");
	printf("For  deleting  use 'delete' \n");
	printf("To end the session use 'bye' \n");
    while(strcmp(com,"bye")){
        scanf("%s",com);
        if(!strcmp(com,"enter")){
            scanf("%s",val);
            add(&head,val);
            printf("Name entered %s\n",val);
        }
        else if(!strcmp(com,"delete")){
            if(emp(&head)){
                x=del(&head,x);// struct pointer için
                printf("Name deleted %s\n",x->name);// struct pointer için
               // printf("Name deleted %s\n",del(&head,val)); bu char array için
               /*
               x=del(&head,x); //struct  normal eleman
               printf("Name deleted %s\n",x.name); //struct  normal eleman
               */
            }else{
                printf("NULL\n");
            }
        }
    }
    
    printf("End session");
    return 0;
}







1 vize sonrası





file denemeler gibi düşün
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
/*

int main(){
char veri[200]="yazilim manyagi";
int len,i;
FILE *p;
p=fopen("first.txt","r");
if(p==NULL){
    printf("nothing");
}else{
    printf("we have one\n");
}
len=strlen(veri);
for(i=0;i<len;i++){
    fputc(veri[i],p);
    printf("%c",veri[i]);
}
printf("\n");
fscanf(p,"%s",veri);
printf("%s\n",veri);
fclose(p);
printf("\nnp1  baþlangýcýew one\n");
char arr[50];
FILE *p1;
p1=fopen("first.txt","a");
fgets(arr,20,stdin);
fputs(arr,p1);
fclose(p1);
return 0;
}








#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int main(){

	FILE *inp ;
	FILE *outp ;
	double item;
	int input_status;

	inp = fopen("a.txt","r");
	outp = fopen("outp.txt","w");

	input_status = fscanf(inp,"%lf",&item);
	while(input_status == 1){
		fprintf(outp,"%.2f\n",item);
		input_status = fscanf(inp,"%lf",&item);
	}
	fscanf(inp,"%lf",&item);
    printf("\n%.2lf",item);
	fclose(inp);
	fclose(outp);

    return (0);
}
*/








#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int main(){

	FILE *inp ;
	double doub;
	int  num;
	char  arr[200];

	inp = fopen("first.txt","r");
    //fprintf(inp,"I love ebru when she gives a blow job");
    //fprintf(inp,"\nso then she let me cum her inside and never set me free until my ball's are empty");
    //fprintf(inp,"\nso then finally,she accepts me as her beloved one,of course I also fucked her ass");
   /* while(!feof(inp)){
        fgets(arr,200,inp);
        //puts(arr);
        printf("%s",arr);
        }
        printf("\n");
    */
     while(!feof(inp)){
        fscanf(inp,"%s",arr);
        //puts(arr); word word yazdırıyor ve hep \n yapıyor
        printf("%s",arr);
        // karısık durumlar var  printf de kelimeler arasında boşluk yok ve \n yapmıyor
    }

    fclose(inp);
    return (0);
}
